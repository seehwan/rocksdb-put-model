<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RocksDB Put-Rate Model v4: Theoretical Foundation</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        .version-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 20px;
        }
        .model-evolution {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            margin: 20px 0;
        }
        .v4-innovation {
            background: #e8f5e8;
            border: 1px solid #28a745;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .formula-box {
            background: #f8f9fa;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        .limitation-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="version-badge">PutModel v4.0 - Theoretical Foundation</div>
            <h1>RocksDB Put-Rate Model v4: 이론적 배경과 수식</h1>
            <p>이 문서는 PutModel v4의 이론적 배경, 수식 유도, 그리고 v3 모델의 한계를 해결하는 방법을 정리합니다. <strong>Device Envelope Modeling</strong>, <strong>Closed Ledger Accounting</strong>, <strong>Dynamic Simulation</strong>의 수학적 기반을 제공합니다.</p>
            <blockquote>
                <p>실제 구현은 <code>PutModel_v4_Implementation.html</code>을, 실험 결과는 <code>PutModel_v4_Experimental.html</code>을 참조하세요.</p>
            </blockquote>
        </header>

        <div class="content-wrapper">
            <nav class="toc-sidebar">
                <h3>목차</h3>
                <ul>
                    <li><a href="#overview">0) v4 모델 개요</a></li>
                    <li><a href="#v3-limitations">1) v3 모델의 한계점</a></li>
                    <li><a href="#device-envelope">2) Device Envelope Modeling</a></li>
                    <li><a href="#closed-ledger">3) Closed Ledger Accounting</a></li>
                    <li><a href="#dynamic-simulation">4) Dynamic Simulation Framework</a></li>
                    <li><a href="#mathematical-foundation">5) 수학적 기반</a></li>
                    <li><a href="#calibration-validation">6) 캘리브레이션과 검증 분리</a></li>
                    <li><a href="#per-level-analysis">7) Per-Level 분석</a></li>
                    <li><a href="#convergence-conditions">8) 수렴 조건</a></li>
                    <li><a href="#optimization-theory">9) 최적화 이론</a></li>
                    <li><a href="#limitations">10) 한계와 확장</a></li>
                </ul>
            </nav>
            <main>
                <section id="overview">
                    <h2>0) v4 모델 개요</h2>
                    
                    <div class="model-evolution">
                        <h3>모델 진화 과정</h3>
                        <ul>
                            <li><strong>v1-v2.1:</strong> 기본 closed-form 모델 (Harmonic Mean 가정)</li>
                            <li><strong>v3:</strong> Stall 모델링과 per-level 제약 추가</li>
                            <li><strong>v4:</strong> Device Envelope + Closed Ledger + Dynamic Simulation</li>
                        </ul>
                    </div>

                    <h3>v4의 핵심 혁신</h3>
                    <div class="v4-innovation">
                        <ul>
                            <li><strong>Device Envelope Modeling:</strong> fio 그리드 스윕으로 실제 장치 특성 반영</li>
                            <li><strong>Closed Ledger Accounting:</strong> 물리적 검증을 통한 회계 폐곡선</li>
                            <li><strong>Dynamic Simulation:</strong> 시간가변 시스템 동작 모델링</li>
                            <li><strong>Calibration/Validation Separation:</strong> 엄격한 분리로 순환 검증 방지</li>
                        </ul>
                    </div>

                    <h3>모델의 입력과 출력</h3>
                    <ul>
                        <li><strong>입력:</strong> 장치 엔벌롭, DB 옵션, 워크로드 특성, 트리거/스톨 임계값</li>
                        <li><strong>출력:</strong> 시간 t에서의 put 처리량, 레벨별 처리율/대기열</li>
                    </ul>
                </section>

                <section id="v3-limitations">
                    <h2>1) v3 모델의 한계점</h2>
                    
                    <h3>1.1 혼합 I/O 대역폭의 물리적 불일치</h3>
                    <div class="limitation-box">
                        <p><strong>문제:</strong> Harmonic Mean 가정 $B_{eff} = \frac{1}{\rho_r/B_r + \rho_w/B_w}$는 다음을 무시합니다:</p>
                        <ul>
                            <li>큐 깊이(queue depth)에 따른 장치 간섭</li>
                            <li>병렬도(numjobs)의 영향</li>
                            <li>블록 크기(block size)의 효과</li>
                            <li>일부 실측값이 HM의 물리적 상한 $\min(B_r, B_w)$를 초과</li>
                        </ul>
                    </div>

                    <h3>1.2 수치/정의의 자기모순</h3>
                    <ul>
                        <li>WA/RA/혼합 비율과 합계가 표·본문·통계 간 불일치</li>
                        <li>GB vs GiB, 절대치(B) vs 정규화(η)의 혼용</li>
                        <li>단위 표준화 부재</li>
                    </ul>

                    <h3>1.3 검증의 순환성</h3>
                    <ul>
                        <li>LOG 기반 WA 값을 모델 입력으로 사용하면서 "0% 오차" 주장</li>
                        <li>캘리브레이션 ≠ 검증의 혼동</li>
                    </ul>

                    <h3>1.4 Per-level 지표 정의 미흡</h3>
                    <ul>
                        <li>Compaction In/Out/Read/Write에 대한 정의 부재</li>
                        <li>추출식과 로그 컬럼 매핑 부재</li>
                    </ul>
                </section>

                <section id="device-envelope">
                    <h2>2) Device Envelope Modeling</h2>
                    
                    <h3>2.1 4D 그리드 스윕</h3>
                    <p>fio를 사용한 체계적 장치 특성 측정:</p>
                    <ul>
                        <li>$\rho_r \in \{0, 25, 50, 75, 100\}\%$ (읽기 비율)</li>
                        <li>$\text{iodepth} \in \{1, 4, 16, 64\}$ (큐 깊이)</li>
                        <li>$\text{numjobs} \in \{1, 2, 4\}$ (병렬 작업 수)</li>
                        <li>$\text{bs} \in \{4, 64, 1024\}$ KiB (블록 크기)</li>
                    </ul>
                    <p><strong>총 조합:</strong> $5 \times 4 \times 3 \times 3 = 180$개 포인트</p>

                    <h3>2.2 엔벌롭 모델 수식</h3>
                    <div class="formula-box">
                        <p><strong>혼합 I/O 대역폭:</strong></p>
                        <p>$$B_{eff} = \text{Envelope}(\rho_r, qd, \text{numjobs}, bs; \Theta_{device})$$</p>
                        <p>여기서 $\Theta_{device}$는 fio 스윕으로 획득한 4D 격자 + 선형보간 테이블</p>
                    </div>

                    <h3>2.3 선형보간과 클램프</h3>
                    <p>4D 선형보간을 통한 연속 함수 근사:</p>
                    <ul>
                        <li><strong>보간:</strong> scipy.interpolate.RegularGridInterpolator 사용</li>
                        <li><strong>클램프:</strong> $B_{eff} \leq \min(B_r, B_w)$ 물리적 상한 적용</li>
                        <li><strong>외삽 경고:</strong> 격자 범위 초과 시 경고 출력</li>
                    </ul>
                </section>

                <section id="closed-ledger">
                    <h2>3) Closed Ledger Accounting</h2>
                    
                    <h3>3.1 회계 정의</h3>
                    <div class="formula-box">
                        <p><strong>WA 계산:</strong></p>
                        <p>$$\text{WA}_{stat} = \frac{\text{WAL} + \text{Flush} + \sum_{\ell} \text{CompWrite}_{\ell}}{\text{UserWrite}}$$</p>
                        <p>$$\text{WA}_{device} = \frac{\text{DeviceWrite}}{\text{UserWrite}}$$</p>
                        
                        <p><strong>RA 계산:</strong></p>
                        <p>$$\text{RA}_{comp} = \frac{\sum_{\ell} \text{CompRead}_{\ell}}{\text{UserWrite}}$$</p>
                        <p>$$\text{RA}_{runtime} = \frac{\text{DeviceRead}}{\text{UserWrite}}$$</p>
                    </div>

                    <h3>3.2 폐곡선 검증</h3>
                    <p><strong>검증 목표:</strong> 동일 런에서 위 항들이 물리적으로 닫히는지 확인 (±10% 이내)</p>
                    <ul>
                        <li>$\text{UserWrite} \rightarrow (\text{WAL} + \text{Flush} + \sum \text{CompWrite}) \leftrightarrow \text{DeviceWrite}$</li>
                        <li>회계 폐곡선: $\left|\text{WA}_{stat} - \text{WA}_{device}\right| \leq 10\%$</li>
                    </ul>

                    <h3>3.3 단위 표준화</h3>
                    <ul>
                        <li>GiB/GB 명확화</li>
                        <li>절대치 B(=MiB/s) vs 정규화 η(무차원) 구분</li>
                        <li>일관된 단위 체계 적용</li>
                    </ul>
                </section>

                <section id="dynamic-simulation">
                    <h2>4) Dynamic Simulation Framework</h2>
                    
                    <h3>4.1 핵심 수식</h3>
                    <div class="formula-box">
                        <p><strong>레벨 ℓ의 순간 처리용량:</strong></p>
                        <p>$$C_{\ell}(t) = \mu_{\ell} \cdot k_{\ell} \cdot \eta_{\ell}(t) \cdot B_{eff}(t)$$</p>
                        <ul>
                            <li>$\mu_{\ell}$: 스케줄러/서브컴팩션/리드어헤드 등 상수 계수</li>
                            <li>$k_{\ell}$: 코덱/블록크기/팬인 영향 상수</li>
                            <li>$\eta_{\ell}(t)$: 시간가변 효율 (경합·혼합비·컨디션 반영)</li>
                            <li>$B_{eff}(t)$: 엔벌롭 보간값</li>
                        </ul>
                    </div>

                    <h3>4.2 Backlog 동역학</h3>
                    <div class="formula-box">
                        <p><strong>큐 동역학:</strong></p>
                        <p>$$Q_{\ell}(t+\Delta) = \max\{0, Q_{\ell}(t) + I_{\ell}(t) - C_{\ell}(t) \cdot \Delta\}$$</p>
                        <p>여기서 $I_{\ell}(t)$는 상위 레벨 outflow (Flush 또는 L(ℓ-1) compaction out)</p>
                    </div>

                    <h3>4.3 시간가변 효율</h3>
                    <p>$\eta_{\ell}(t)$는 다음을 반영합니다:</p>
                    <ul>
                        <li><strong>경합 효과:</strong> 동시 작업 간 리소스 경합</li>
                        <li><strong>혼합비:</strong> 읽기/쓰기 비율의 영향</li>
                        <li><strong>컨디션:</strong> 시스템 상태와 환경 변화</li>
                    </ul>
                </section>

                <section id="mathematical-foundation">
                    <h2>5) 수학적 기반</h2>
                    
                    <h3>5.1 최적화 문제</h3>
                    <div class="formula-box">
                        <p><strong>제약 조건:</strong></p>
                        <p>$$\begin{align}
                        \text{(W)} \quad &W(S) \leq B_w \\
                        \text{(R)} \quad &R(S) \leq B_r \\
                        \text{(M)} \quad &W(S) + R(S) \leq B_{eff}
                        \end{align}$$</p>
                        
                        <p><strong>목적 함수:</strong></p>
                        <p>$$S_{\max} = \min\{S_w, S_r, S_m\}$$</p>
                    </div>

                    <h3>5.2 레벨별 분해</h3>
                    <p>Mass-Balance 관점에서의 레벨별 기여:</p>
                    <div class="formula-box">
                        <p>$$W_i(S) = \frac{S}{CR} \cdot \alpha_i, \quad R_i(S) = \frac{S}{CR} \cdot \beta_i$$</p>
                        <p>여기서 $\sum_i \alpha_i = WA$, $\sum_i \beta_i = RA_c$</p>
                    </div>

                    <h3>5.3 수렴성 분석</h3>
                    <p>시스템이 steady state로 수렴하는 조건:</p>
                    <ul>
                        <li>평균 유입이 용량 이하: $\lambda \leq S_{\max}$</li>
                        <li>제어기 안정성: 적절한 피드백 게인</li>
                        <li>외부 캡: $S_{acc} \leq S_{\max}$</li>
                    </ul>
                </section>

                <section id="calibration-validation">
                    <h2>6) 캘리브레이션과 검증 분리</h2>
                    
                    <h3>6.1 Phase-A: 캘리브레이션</h3>
                    <ul>
                        <li><strong>장치 엔벌롭 측정:</strong> fio 그리드 스윕</li>
                        <li><strong>상수 보정:</strong> $\mu_{\ell}$, $k_{\ell}$ 계수 결정</li>
                        <li><strong>환경 안정화:</strong> NVMe 온도/전력 프로파일 고정</li>
                    </ul>

                    <h3>6.2 Phase-D: 검증</h3>
                    <ul>
                        <li><strong>홀드아웃 평가:</strong> 캘리브레이션에 사용되지 않은 데이터</li>
                        <li><strong>성능 메트릭:</strong> MAPE, NRMSE 계산</li>
                        <li><strong>수용 기준:</strong> MAPE ≤ 10-15%</li>
                    </ul>

                    <h3>6.3 순환 검증 방지</h3>
                    <ul>
                        <li>Phase-A와 Phase-D 산출물 폴더 분리</li>
                        <li>교차사용 방지 체크</li>
                        <li>메타데이터 추적</li>
                    </ul>
                </section>

                <section id="per-level-analysis">
                    <h2>7) Per-Level 분석</h2>
                    
                    <h3>7.1 레벨별 I/O 분해</h3>
                    <p>각 레벨에서의 읽기/쓰기 기여도:</p>
                    <ul>
                        <li><strong>L0:</strong> Flush 쓰기, Compaction 읽기</li>
                        <li><strong>L1-Lk:</strong> Compaction 읽기/쓰기</li>
                        <li><strong>WAL:</strong> 동기/비동기 쓰기</li>
                    </ul>

                    <h3>7.2 병목 진단</h3>
                    <p>어느 레벨에서 병목이 발생하는지 시각화:</p>
                    <ul>
                        <li>레벨별 처리용량 $C_{\ell}(t)$</li>
                        <li>레벨별 백로그 $Q_{\ell}(t)$</li>
                        <li>리소스 활용률 분석</li>
                    </ul>

                    <h3>7.3 튜닝 포인트</h3>
                    <ul>
                        <li>레벨별 크기 비율 조정</li>
                        <li>Compaction 스케줄링 최적화</li>
                        <li>메모리 할당 균형</li>
                    </ul>
                </section>

                <section id="convergence-conditions">
                    <h2>8) 수렴 조건</h2>
                    
                    <h3>8.1 안정화 판정</h3>
                    <ul>
                        <li><strong>Backlog 안정성:</strong> $Q_{\ell}(t)$의 장기 기울기 ≤ 0</li>
                        <li><strong>처리량 수렴:</strong> $C_{\ell}(t)$의 변동성 감소</li>
                        <li><strong>시스템 균형:</strong> 유입 = 유출</li>
                    </ul>

                    <h3>8.2 과도 상태 분석</h3>
                    <p>빈 DB에서 시작하여 steady state로 수렴하는 과정:</p>
                    <ul>
                        <li><strong>초기 버스트:</strong> $S_{in} > S_{\max}$ 상황</li>
                        <li><strong>제어기 동작:</strong> 속도 조절과 스톨</li>
                        <li><strong>수렴 시간:</strong> 안정화까지의 시간</li>
                    </ul>

                    <h3>8.3 수렴성 보장</h3>
                    <div class="formula-box">
                        <p><strong>Lyapunov 함수:</strong></p>
                        <p>$$V(t) = \sum_{\ell} Q_{\ell}^2(t)$$</p>
                        <p>$\dot{V}(t) < 0$이면 시스템이 안정적으로 수렴</p>
                    </div>
                </section>

                <section id="optimization-theory">
                    <h2>9) 최적화 이론</h2>
                    
                    <h3>9.1 성능 최적화</h3>
                    <ul>
                        <li><strong>대역폭 최적화:</strong> $B_{eff}$ 극대화</li>
                        <li><strong>WA 최소화:</strong> Compaction 효율성 향상</li>
                        <li><strong>지연 최소화:</strong> Backlog 관리</li>
                    </ul>

                    <h3>9.2 리소스 할당</h3>
                    <p>제한된 리소스 하에서 최적 성능 달성:</p>
                    <ul>
                        <li>CPU/메모리/I/O 대역폭 균형</li>
                        <li>레벨별 우선순위 설정</li>
                        <li>동적 조정 메커니즘</li>
                    </ul>

                    <h3>9.3 적응적 제어</h3>
                    <p>워크로드 변화에 따른 동적 조정:</p>
                    <ul>
                        <li>실시간 모니터링</li>
                        <li>피드백 제어</li>
                        <li>예측적 조정</li>
                    </ul>
                </section>

                <section id="limitations">
                    <h2>10) 한계와 확장</h2>
                    
                    <h3>10.1 현재 한계</h3>
                    <ul>
                        <li><strong>CPU 병목:</strong> 압축/해제, 체크섬 계산</li>
                        <li><strong>메모리 제약:</strong> 캐시 크기와 메모리 대역폭</li>
                        <li><strong>네트워크 지연:</strong> 분산 환경에서의 통신 오버헤드</li>
                    </ul>

                    <h3>10.2 확장 가능성</h3>
                    <ul>
                        <li><strong>다중 장치:</strong> WAL 분리, 계층적 저장</li>
                        <li><strong>분산 시스템:</strong> 클러스터 환경 모델링</li>
                        <li><strong>적응적 모델:</strong> 머신러닝 기반 파라미터 조정</li>
                    </ul>

                    <h3>10.3 미래 연구 방향</h3>
                    <ul>
                        <li>실시간 성능 예측</li>
                        <li>자동 튜닝 시스템</li>
                        <li>하이브리드 저장소 모델링</li>
                    </ul>
                </section>
            </main>
        </div>

        <footer>
            <p>&copy; 2025 RocksDB Put-Rate Model v4. All rights reserved.</p>
            <p>Last updated: September 7, 2025</p>
        </footer>
    </div>
</body>
</html>
