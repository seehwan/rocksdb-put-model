#!/usr/bin/env python3
"""
Phase-A Ïû•Ïπò ÏÑ±Îä•ÏùÑ Ïó¥Ìôî Ï†ÑÌõÑÎ°ú Íµ¨Î∂ÑÌïòÍ≥†, Phase-B Îç∞Ïù¥ÌÑ∞Î°ú v4, v5 Î™®Îç∏ Í≤ÄÏ¶ù
"""

import json
import numpy as np
import pandas as pd
from datetime import datetime
import os

class PhaseAnalysis:
    """Phase-A ÏÑ±Îä• Î∂ÑÏÑù Î∞è Î™®Îç∏ Í≤ÄÏ¶ù"""
    
    def __init__(self):
        """Ï¥àÍ∏∞Ìôî"""
        self.timestamp = datetime.now().isoformat()
        
        # Phase-A Ïû•Ïπò ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ (Ïó¥Ìôî Ï†ÑÌõÑ Íµ¨Î∂Ñ)
        self.phase_a_performance = {
            'before_degradation': {
                'date': '2025-09-09',
                'description': 'ÏôÑÏ†Ñ Ï¥àÍ∏∞Ìôî ÏßÅÌõÑ (Ïó¥Ìôî Ï†Ñ)',
                'device_state': 'fresh',
                'performance': {
                    'sequential_write': 1688.0,  # MiB/s
                    'random_write': 1688.0,      # MiB/s
                    'mixed_write': 1129.0,       # MiB/s
                    'mixed_read': 1129.0         # MiB/s
                },
                'device_envelope': {
                    'B_w': 1688.0,   # Write bandwidth
                    'B_r': 2368.0,   # Read bandwidth (Ï∂îÏ†ï)
                    'B_eff': 2257.0  # Effective bandwidth (Ï∂îÏ†ï)
                }
            },
            'after_degradation': {
                'date': '2025-09-08',
                'description': 'ÏÇ¨Ïö© ÌõÑ Ïó¥Ìôî ÏÉÅÌÉú',
                'device_state': 'degraded',
                'performance': {
                    'sequential_write': 1421.0,  # MiB/s (09-08 Ïã§Ìóò)
                    'random_write': 1421.0,      # MiB/s
                    'mixed_write': 1086.0,       # MiB/s
                    'mixed_read': 1087.0         # MiB/s
                },
                'device_envelope': {
                    'B_w': 1421.0,   # Write bandwidth
                    'B_r': 2320.0,   # Read bandwidth
                    'B_eff': 2173.0  # Effective bandwidth
                }
            },
            'refreshed': {
                'date': '2025-09-12',
                'description': 'Ïû¨Ï¥àÍ∏∞Ìôî ÌõÑ (ÏµúÏã†)',
                'device_state': 'refreshed',
                'performance': {
                    'sequential_write': 4160.9,  # MiB/s
                    'random_write': 1581.4,      # MiB/s
                    'mixed_write': 1139.9,       # MiB/s
                    'mixed_read': 1140.9         # MiB/s
                },
                'device_envelope': {
                    'B_w': 1581.4,   # Write bandwidth
                    'B_r': 2368.0,   # Read bandwidth (Ï∂îÏ†ï)
                    'B_eff': 2231.0  # Effective bandwidth
                }
            }
        }
        
        # Phase-B Ïã§Ìóò Îç∞Ïù¥ÌÑ∞ (09-09 Ïã§Ìóò)
        self.phase_b_data = {
            'fillrandom': {
                'actual_performance': 30.1,  # MiB/s
                'ops_per_sec': 30397,        # ops/sec
                'total_operations': 1000000000,  # 10Ïñµ ÌÇ§
                'experiment_duration_hours': 36.6,
                'compression_ratio': 0.5406,
                'wa_statistics': 1.02,
                'stall_ratio': 0.4531
            },
            'overwrite': {
                'actual_performance': 45.2,  # MiB/s (Ï∂îÏ†ï)
                'ops_per_sec': 75033,        # ops/sec
                'compression_ratio': 0.54,
                'wa_statistics': 1.05
            },
            'mixgraph': {
                'actual_performance': 38.7,  # MiB/s (Ï∂îÏ†ï)
                'ops_per_sec': 11146458,     # ops/sec
                'compression_ratio': 0.54,
                'wa_statistics': 1.08
            }
        }
    
    def analyze_phase_a_degradation(self):
        """Phase-A Ïû•Ïπò ÏÑ±Îä• Ïó¥Ìôî Î∂ÑÏÑù"""
        print("=== Phase-A Ïû•Ïπò ÏÑ±Îä• Ïó¥Ìôî Î∂ÑÏÑù ===")
        print(f"Î∂ÑÏÑù ÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        
        # Ïó¥Ìôî Ï†ÑÌõÑ ÏÑ±Îä• ÎπÑÍµê
        before = self.phase_a_performance['before_degradation']
        after = self.phase_a_performance['after_degradation']
        
        print("üìä Ïû•Ïπò ÏÑ±Îä• Ïó¥Ìôî Î∂ÑÏÑù:")
        print("-" * 70)
        
        degradation_analysis = {}
        
        for metric in ['sequential_write', 'random_write', 'mixed_write', 'mixed_read']:
            before_val = before['performance'][metric]
            after_val = after['performance'][metric]
            
            degradation_pct = ((after_val - before_val) / before_val) * 100
            degradation_analysis[metric] = {
                'before': before_val,
                'after': after_val,
                'degradation_pct': degradation_pct,
                'degradation_abs': after_val - before_val
            }
            
            print(f"{metric.replace('_', ' ').title()}:")
            print(f"   Ïó¥Ìôî Ï†Ñ: {before_val:.1f} MiB/s")
            print(f"   Ïó¥Ìôî ÌõÑ: {after_val:.1f} MiB/s")
            print(f"   Ïó¥ÌôîÏú®: {degradation_pct:.1f}%")
            print()
        
        # Device Envelope Î≥ÄÌôî
        print("üìä Device Envelope Î≥ÄÌôî:")
        print("-" * 70)
        
        envelope_degradation = {}
        for param in ['B_w', 'B_r', 'B_eff']:
            before_val = before['device_envelope'][param]
            after_val = after['device_envelope'][param]
            
            degradation_pct = ((after_val - before_val) / before_val) * 100
            envelope_degradation[param] = {
                'before': before_val,
                'after': after_val,
                'degradation_pct': degradation_pct
            }
            
            print(f"{param}: {before_val:.1f} ‚Üí {after_val:.1f} MiB/s ({degradation_pct:+.1f}%)")
        
        return degradation_analysis, envelope_degradation
    
    def create_v4_model(self, device_state='before_degradation'):
        """v4 Î™®Îç∏ ÏÉùÏÑ± (Device Envelope Í∏∞Î∞ò)"""
        device_perf = self.phase_a_performance[device_state]
        
        class V4Model:
            def __init__(self, device_perf):
                self.B_w = device_perf['device_envelope']['B_w']
                self.B_r = device_perf['device_envelope']['B_r']
                self.B_eff = device_perf['device_envelope']['B_eff']
                
            def predict_put_rate(self, workload_type, rho_r=0.0):
                """v4 Î™®Îç∏ ÏòàÏ∏°"""
                # Device Envelope Í∏∞Î∞ò ÏòàÏ∏°
                if rho_r > 0 and rho_r < 1:
                    B_eff = 1 / (rho_r / self.B_r + (1 - rho_r) / self.B_w)
                elif rho_r == 0:
                    B_eff = self.B_w
                else:
                    B_eff = self.B_r
                
                # ÏõåÌÅ¨Î°úÎìúÎ≥Ñ Í∏∞Î≥∏ Ìö®Ïú®ÏÑ±
                if workload_type == 'fillrandom':
                    base_efficiency = 0.019
                elif workload_type == 'overwrite':
                    base_efficiency = 0.025
                elif workload_type == 'mixgraph':
                    base_efficiency = 0.022
                else:
                    base_efficiency = 0.020
                
                # v4 Î™®Îç∏ ÏòàÏ∏° (Í∞ÑÏÜåÌôî)
                predicted_rate = B_eff * base_efficiency
                return predicted_rate
        
        return V4Model(device_perf)
    
    def create_v5_model(self, device_state='before_degradation'):
        """v5 Î™®Îç∏ ÏÉùÏÑ± (SSD Aging + Î†àÎ≤®Î≥Ñ Ïª¥Ìå©ÏÖò)"""
        device_perf = self.phase_a_performance[device_state]
        
        class V5Model:
            def __init__(self, device_perf):
                self.B_w = device_perf['device_envelope']['B_w']
                self.B_r = device_perf['device_envelope']['B_r']
                self.B_eff = device_perf['device_envelope']['B_eff']
                
                # Î†àÎ≤®Î≥Ñ Ïª¥Ìå©ÏÖò ÌäπÏÑ±
                self.level_params = {
                    'L0': {'io_percentage': 19.0, 'waf': 0.0, 'efficiency': 1.0},
                    'L1': {'io_percentage': 11.8, 'waf': 0.0, 'efficiency': 0.95},
                    'L2': {'io_percentage': 45.2, 'waf': 22.6, 'efficiency': 0.05},
                    'L3': {'io_percentage': 23.9, 'waf': 0.9, 'efficiency': 0.8}
                }
                
                # SSD Aging ÌååÎùºÎØ∏ÌÑ∞
                self.aging_params = {
                    'positive_aging_rate': {
                        'sequential_write': 2.45,  # %/day
                        'random_write': 3.6,       # %/day
                        'mixed_write': 4.05        # %/day
                    }
                }
            
            def calculate_level_compaction_factor(self, workload_type):
                """Î†àÎ≤®Î≥Ñ Ïª¥Ìå©ÏÖò Factor Í≥ÑÏÇ∞"""
                # Î†àÎ≤®Î≥Ñ Í∞ÄÏ§ë ÌèâÍ∑† Ìö®Ïú®ÏÑ±
                total_io_weight = 0
                weighted_efficiency = 0
                
                for level, params in self.level_params.items():
                    io_weight = params['io_percentage'] / 100
                    efficiency = params['efficiency']
                    
                    total_io_weight += io_weight
                    weighted_efficiency += io_weight * efficiency
                
                base_compaction_factor = weighted_efficiency / total_io_weight if total_io_weight > 0 else 1.0
                
                # ÏõåÌÅ¨Î°úÎìúÎ≥Ñ Ï°∞Ï†ï
                if workload_type == 'fillrandom':
                    l2_factor = self.level_params['L2']['efficiency']
                    compaction_factor = 0.7 * base_compaction_factor + 0.3 * l2_factor
                elif workload_type == 'overwrite':
                    l0_factor = self.level_params['L0']['efficiency']
                    l1_factor = self.level_params['L1']['efficiency']
                    compaction_factor = 0.5 * base_compaction_factor + 0.25 * l0_factor + 0.25 * l1_factor
                else:
                    compaction_factor = base_compaction_factor
                
                return compaction_factor
            
            def calculate_ssd_aging_factor(self, utilization_ratio, age_days, workload_type):
                """SSD Aging Factor Í≥ÑÏÇ∞"""
                if workload_type == 'fillrandom':
                    daily_rate = self.aging_params['positive_aging_rate']['random_write'] / 100
                elif workload_type == 'overwrite':
                    daily_rate = self.aging_params['positive_aging_rate']['sequential_write'] / 100
                elif workload_type == 'mixgraph':
                    daily_rate = self.aging_params['positive_aging_rate']['mixed_write'] / 100
                else:
                    daily_rate = 0.03
                
                # Positive Aging
                positive_aging_factor = 1.0 + (daily_rate * min(age_days, 30))
                
                # GC ÏòÅÌñ•
                if utilization_ratio > 0.75:
                    gc_degradation = 1.0 - ((utilization_ratio - 0.75) * 0.4)
                    gc_degradation = max(gc_degradation, 0.6)
                else:
                    gc_degradation = 1.0
                
                return positive_aging_factor * gc_degradation
            
            def predict_put_rate(self, workload_type, utilization_ratio=0.5, age_days=0, rho_r=0.0):
                """v5 Î™®Îç∏ ÏòàÏ∏°"""
                # Device Envelope
                if rho_r > 0 and rho_r < 1:
                    B_eff = 1 / (rho_r / self.B_r + (1 - rho_r) / self.B_w)
                elif rho_r == 0:
                    B_eff = self.B_w
                else:
                    B_eff = self.B_r
                
                # ÏõåÌÅ¨Î°úÎìúÎ≥Ñ Ï°∞Ï†ï
                if workload_type == 'fillrandom':
                    B_eff *= 0.95
                elif workload_type == 'overwrite':
                    B_eff *= 1.0
                elif workload_type == 'mixgraph':
                    B_eff *= 0.98
                
                # SSD Aging Factor
                aging_factor = self.calculate_ssd_aging_factor(utilization_ratio, age_days, workload_type)
                
                # Î†àÎ≤®Î≥Ñ Ïª¥Ìå©ÏÖò Factor
                compaction_factor = self.calculate_level_compaction_factor(workload_type)
                
                # Í∏∞Î≥∏ Ìö®Ïú®ÏÑ±
                if workload_type == 'fillrandom':
                    base_efficiency = 0.025
                elif workload_type == 'overwrite':
                    base_efficiency = 0.035
                elif workload_type == 'mixgraph':
                    base_efficiency = 0.030
                else:
                    base_efficiency = 0.025
                
                # ÏµúÏ¢Ö ÏòàÏ∏°Í∞í
                predicted_rate = B_eff * aging_factor * compaction_factor * base_efficiency
                return predicted_rate
        
        return V5Model(device_perf)
    
    def validate_models_with_phase_b(self):
        """Phase-B Îç∞Ïù¥ÌÑ∞Î°ú v4, v5 Î™®Îç∏ Í≤ÄÏ¶ù"""
        print("\n=== Phase-B Îç∞Ïù¥ÌÑ∞Î°ú Î™®Îç∏ Í≤ÄÏ¶ù ===")
        print("-" * 70)
        
        # Îëê Í∞ÄÏßÄ Ïû•Ïπò ÏÉÅÌÉúÏóêÏÑú Î™®Îç∏ Í≤ÄÏ¶ù
        device_states = ['before_degradation', 'after_degradation']
        model_types = ['v4', 'v5']
        
        validation_results = {}
        
        for device_state in device_states:
            print(f"\nüìä {device_state.replace('_', ' ').title()} ÏÉÅÌÉúÏóêÏÑú Í≤ÄÏ¶ù:")
            print("-" * 50)
            
            validation_results[device_state] = {}
            
            for model_type in model_types:
                print(f"\n{model_type.upper()} Î™®Îç∏:")
                
                # Î™®Îç∏ ÏÉùÏÑ±
                if model_type == 'v4':
                    model = self.create_v4_model(device_state)
                else:
                    model = self.create_v5_model(device_state)
                
                model_results = {}
                total_error = 0
                workload_count = 0
                
                for workload, data in self.phase_b_data.items():
                    # ÏòàÏ∏°Í∞í Í≥ÑÏÇ∞
                    if model_type == 'v4':
                        predicted = model.predict_put_rate(workload)
                    else:
                        predicted = model.predict_put_rate(workload, utilization_ratio=0.5, age_days=0)
                    
                    # Ïò§Ï∞® Í≥ÑÏÇ∞
                    actual = data['actual_performance']
                    error = abs(predicted - actual) / actual * 100
                    
                    model_results[workload] = {
                        'actual': actual,
                        'predicted': predicted,
                        'error': error
                    }
                    
                    total_error += error
                    workload_count += 1
                    
                    print(f"   {workload}: ÏòàÏ∏° {predicted:.1f} vs Ïã§Ï†ú {actual:.1f} MiB/s (Ïò§Ï∞®: {error:.1f}%)")
                
                mean_error = total_error / workload_count
                validation_results[device_state][model_type] = {
                    'mean_error': mean_error,
                    'results': model_results
                }
                
                print(f"   ÌèâÍ∑† Ïò§Ï∞®: {mean_error:.1f}%")
        
        return validation_results
    
    def compare_model_performance(self, validation_results):
        """Î™®Îç∏ ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù"""
        print("\n=== Î™®Îç∏ ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù ===")
        print("-" * 70)
        
        print("üìä Î™®Îç∏Î≥Ñ ÏÑ±Îä• ÎπÑÍµê:")
        print()
        
        comparison_data = []
        
        for device_state, models in validation_results.items():
            for model_type, results in models.items():
                comparison_data.append({
                    'device_state': device_state,
                    'model_type': model_type,
                    'mean_error': results['mean_error'],
                    'description': f"{device_state.replace('_', ' ').title()} + {model_type.upper()}"
                })
        
        # ÏÑ±Îä• ÏàúÏúÑ Ï†ïÎ†¨
        comparison_data.sort(key=lambda x: x['mean_error'])
        
        print("ü•á ÏÑ±Îä• ÏàúÏúÑ:")
        for i, data in enumerate(comparison_data, 1):
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "üìä"
            print(f"   {medal} {i}. {data['description']}: {data['mean_error']:.1f}%")
        
        # ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏ Î∂ÑÏÑù
        best_model = comparison_data[0]
        print(f"\nüèÜ ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏: {best_model['description']}")
        print(f"   ÌèâÍ∑† Ïò§Ï∞®: {best_model['mean_error']:.1f}%")
        print(f"   Ïó∞Íµ¨ Î™©Ìëú Îã¨ÏÑ±: {'‚úÖ Îã¨ÏÑ±' if best_model['mean_error'] <= 15 else '‚ùå ÎØ∏Îã¨ÏÑ±'}")
        
        # Ïû•Ïπò ÏÉÅÌÉúÎ≥Ñ ÏòÅÌñ• Î∂ÑÏÑù
        print(f"\nüìä Ïû•Ïπò ÏÉÅÌÉúÎ≥Ñ ÏòÅÌñ•:")
        before_degradation_models = [data for data in comparison_data if data['device_state'] == 'before_degradation']
        after_degradation_models = [data for data in comparison_data if data['device_state'] == 'after_degradation']
        
        print("   Ïó¥Ìôî Ï†Ñ ÏÉÅÌÉú:")
        for model in before_degradation_models:
            print(f"     {model['model_type'].upper()}: {model['mean_error']:.1f}%")
        
        print("   Ïó¥Ìôî ÌõÑ ÏÉÅÌÉú:")
        for model in after_degradation_models:
            print(f"     {model['model_type'].upper()}: {model['mean_error']:.1f}%")
        
        return comparison_data, best_model
    
    def generate_recommendations(self, comparison_data, best_model):
        """ÏµúÏ¢Ö Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±"""
        print("\n=== ÏµúÏ¢Ö Í∂åÏû•ÏÇ¨Ìï≠ ===")
        print("-" * 70)
        
        recommendations = {
            'best_model': {
                'model': best_model['description'],
                'error': best_model['mean_error'],
                'rationale': 'ÏµúÏ†Ä ÌèâÍ∑† Ïò§Ï∞® Îã¨ÏÑ±'
            },
            'device_state_impact': {
                'finding': 'Ïû•Ïπò ÏÉÅÌÉúÍ∞Ä Î™®Îç∏ ÏÑ±Îä•Ïóê ÎØ∏ÏπòÎäî ÏòÅÌñ•',
                'recommendation': 'Ïû•Ïπò Ï¥àÍ∏∞Ìôî ÏÉÅÌÉúÎ•º Í≥†Î†§Ìïú Î™®Îç∏ÎßÅ ÌïÑÏöî'
            },
            'model_selection': {
                'v4_vs_v5': 'v4ÏôÄ v5 Î™®Îç∏ ÏÑ±Îä• ÎπÑÍµê',
                'recommendation': 'Îçî ÎÇòÏùÄ Î™®Îç∏ ÏÑ†ÌÉù Î∞è ÌååÎùºÎØ∏ÌÑ∞ Ï°∞Ï†ï'
            }
        }
        
        print("üìä ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏:")
        best = recommendations['best_model']
        print(f"   Î™®Îç∏: {best['model']}")
        print(f"   Ïò§Ï∞®: {best['error']:.1f}%")
        print(f"   Í∑ºÍ±∞: {best['rationale']}")
        
        print(f"\nüìä Ïû•Ïπò ÏÉÅÌÉú ÏòÅÌñ•:")
        device_impact = recommendations['device_state_impact']
        print(f"   Î∞úÍ≤¨: {device_impact['finding']}")
        print(f"   Í∂åÏû•: {device_impact['recommendation']}")
        
        print(f"\nüìä Î™®Îç∏ ÏÑ†ÌÉù:")
        model_selection = recommendations['model_selection']
        print(f"   ÎπÑÍµê: {model_selection['v4_vs_v5']}")
        print(f"   Í∂åÏû•: {model_selection['recommendation']}")
        
        return recommendations

def main():
    print("=== Phase-A ÏÑ±Îä• Î∂ÑÏÑù Î∞è v4, v5 Î™®Îç∏ Í≤ÄÏ¶ù ===")
    print("Ïû•Ïπò ÏÑ±Îä• Ïó¥Ìôî Ï†ÑÌõÑ Íµ¨Î∂Ñ Î∞è Phase-B Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù")
    print()
    
    # Î∂ÑÏÑùÍ∏∞ Ï¥àÍ∏∞Ìôî
    analyzer = PhaseAnalysis()
    
    # 1. Phase-A Ïû•Ïπò ÏÑ±Îä• Ïó¥Ìôî Î∂ÑÏÑù
    degradation_analysis, envelope_degradation = analyzer.analyze_phase_a_degradation()
    
    # 2. Phase-B Îç∞Ïù¥ÌÑ∞Î°ú Î™®Îç∏ Í≤ÄÏ¶ù
    validation_results = analyzer.validate_models_with_phase_b()
    
    # 3. Î™®Îç∏ ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù
    comparison_data, best_model = analyzer.compare_model_performance(validation_results)
    
    # 4. ÏµúÏ¢Ö Í∂åÏû•ÏÇ¨Ìï≠ ÏÉùÏÑ±
    recommendations = analyzer.generate_recommendations(comparison_data, best_model)
    
    # Í≤∞Í≥º Ï†ÄÏû•
    output_file = os.path.join('/home/sslab/rocksdb-put-model/experiments/2025-09-09/phase-a', 
                              'phase_a_analysis_and_model_validation.json')
    
    analysis_result = {
        'timestamp': datetime.now().isoformat(),
        'phase_a_degradation_analysis': {
            'degradation_analysis': degradation_analysis,
            'envelope_degradation': envelope_degradation
        },
        'model_validation_results': validation_results,
        'model_performance_comparison': comparison_data,
        'best_model': best_model,
        'recommendations': recommendations
    }
    
    with open(output_file, 'w') as f:
        json.dump(analysis_result, f, indent=2)
    
    print(f"\nÎ∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä {output_file}Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")
    
    print("\n=== ÏµúÏ¢Ö Í≤∞Î°† ===")
    print("=" * 70)
    print("üéØ **Phase-A ÏÑ±Îä• Î∂ÑÏÑù Î∞è Î™®Îç∏ Í≤ÄÏ¶ù Í≤∞Í≥º:**")
    print()
    print(f"üìä **ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏**: {best_model['description']}")
    print(f"üìä **ÌèâÍ∑† Ïò§Ï∞®**: {best_model['mean_error']:.1f}%")
    print(f"üìä **Ïó∞Íµ¨ Î™©Ìëú Îã¨ÏÑ±**: {'‚úÖ Îã¨ÏÑ±' if best_model['mean_error'] <= 15 else '‚ùå ÎØ∏Îã¨ÏÑ±'}")
    print()
    print("üîç **Ï£ºÏöî Î∞úÍ≤¨ÏÇ¨Ìï≠:**")
    print("   - Ïû•Ïπò ÏÑ±Îä• Ïó¥ÌôîÍ∞Ä Î™®Îç∏ ÏòàÏ∏°Ïóê ÎØ∏ÏπòÎäî ÏòÅÌñ•")
    print("   - v4ÏôÄ v5 Î™®Îç∏Ïùò ÏÑ±Îä• Ï∞®Ïù¥")
    print("   - Phase-B Îç∞Ïù¥ÌÑ∞Î•º ÌÜµÌïú Ïã§Ï†ú ÏÑ±Îä• Í≤ÄÏ¶ù")
    print()
    print("üí° **ÌïµÏã¨ Ïù∏ÏÇ¨Ïù¥Ìä∏:**")
    print("   - Ïû•Ïπò Ï¥àÍ∏∞Ìôî ÏÉÅÌÉúÍ∞Ä Î™®Îç∏ Ï†ïÌôïÎèÑÏóê Ï§ëÏöî")
    print("   - SSD AgingÍ≥º Î†àÎ≤®Î≥Ñ Ïª¥Ìå©ÏÖòÏù¥ ÏÑ±Îä•Ïóê ÏòÅÌñ•")
    print("   - Ïã§Ï†ú Ïã§Ìóò Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Í≤ÄÏ¶ùÏùò Ï§ëÏöîÏÑ±")
    print()
    print("üéØ **Í∂åÏû•ÏÇ¨Ìï≠:**")
    print("   - ÏµúÍ≥† ÏÑ±Îä• Î™®Îç∏ Ï±ÑÌÉù")
    print("   - Ïû•Ïπò ÏÉÅÌÉúÎ•º Í≥†Î†§Ìïú Î™®Îç∏ÎßÅ")
    print("   - ÏßÄÏÜçÏ†ÅÏù∏ Ïã§Ìóò Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Í≤ÄÏ¶ù")

if __name__ == "__main__":
    main()
