<!DOCTYPE html>
<html lang="ko">
<head>
    <link rel="stylesheet" href="styles/project.css">

    <link rel="stylesheet" href="styles/project.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RocksDB Put-Rate Model Comprehensive Analysis Report</title>
    
</head>
<body>
    <div class="container">
        <h1>2025-09-12 실험 실행 가이드</h1>
<h2>🎯 실험 개요</h2>
<p><strong>SSD 장치 상태 변화와 시간대별 컴팩션 동작을 관찰하여 RocksDB 안정화 가능성 및 안정적 Put 속도 구하기</strong></p>
<h3>핵심 연구 질문</h3>
<ol>
<li><strong>초기화된 SSD에서 시작한 RocksDB가 안정화될 수 있는가?</strong></li>
<li><strong>안정화된다면 안정적으로 처리할 수 있는 Put 속도는?</strong></li>
<li><strong>시간에 따른 컴팩션 동작과 레벨별 성능 변화는 어떻게 나타나는가?</strong></li>
<li><strong>장치 열화가 FillRandom 성능에 미치는 영향은?</strong></li>
</ol>
<h2>📋 실험 실행 순서</h2>
<h3><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span>: Device Envelope 모델 구축</h3>
<h4>목적</h4>
<p>초기상태 장치 성능과 <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 이후 열화된 상태에서의 장치 성능을 측정하여 Device Envelope 모델 구축</p>
<h4>실행 방법</h4>
<pre class="codehilite"><code class="language-bash">cd /home/sslab/rocksdb-put-model/experiments/2025-09-12
python3 scripts/run_phase_a.py
</code></pre>

<h4>실행 과정</h4>
<ol>
<li><strong>SSD 완전 초기화</strong>: <code>umount</code>, <code>blkdiscard</code>, <code>mkfs.f2fs</code></li>
<li><strong>초기 상태 장치 성능 측정</strong>: fio 그리드 벤치마크 (364개 측정점)</li>
<li><strong><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 실험 진행 안내</strong>: FillRandom 실험 실행 요청</li>
<li><strong>열화 상태 장치 성능 측정</strong>: <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 완료 후 동일한 fio 벤치마크</li>
<li><strong>Device Envelope 모델 구축</strong>: 4D Grid Interpolation + 시간 의존성</li>
</ol>
<h4>예상 소요 시간</h4>
<ul>
<li><strong>초기 상태 측정</strong>: 약 2-3시간</li>
<li><strong>열화 상태 측정</strong>: 약 2-3시간</li>
<li><strong>총 소요 시간</strong>: 약 4-6시간</li>
</ul>
<h3><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span>: FillRandom 성능 분석 및 컴팩션 모니터링</h3>
<h4>목적</h4>
<p>LOG 파일을 저장하고, 시간에 따라 FillRandom 성능과 레벨별 컴팩션량을 분석할 수 있도록 충분한 로그를 사용하고, 시각화를 포함</p>
<h4>실행 방법</h4>
<pre class="codehilite"><code class="language-bash">cd /home/sslab/rocksdb-put-model/experiments/2025-09-12
python3 scripts/run_phase_b.py
</code></pre>

<h4>실행 과정</h4>
<ol>
<li><strong>RocksDB 로깅 설정</strong>: 상세한 로그 설정</li>
<li><strong>Uniform Random FillRandom 실험</strong>: 균등 분포로 FillRandom 실행</li>
<li><strong>Zipfian Random FillRandom 실험</strong>: 지프 분포로 FillRandom 실행</li>
<li><strong>LOG 파일 복사</strong>: 모든 로그 파일을 실험 디렉토리로 복사</li>
<li><strong>성능 트렌드 분석</strong>: 시간별 성능 변화 분석</li>
<li><strong>컴팩션 통계 분석</strong>: 레벨별 컴팩션 패턴 분석</li>
<li><strong>시각화 생성</strong>: 성능, 컴팩션, 안정화 분석 차트</li>
</ol>
<h4>예상 소요 시간</h4>
<ul>
<li><strong>Uniform 분포 실험</strong>: 약 24-48시간</li>
<li><strong>Zipfian 분포 실험</strong>: 약 24-48시간</li>
<li><strong>분석 및 시각화</strong>: 약 1-2시간</li>
<li><strong>총 소요 시간</strong>: 약 48-96시간 (2-4일)</li>
</ul>
<h2>🔧 사전 준비사항</h2>
<h3>1. 시스템 요구사항</h3>
<ul>
<li><strong>CPU</strong>: Intel i9-12900K (16 cores, 24 threads)</li>
<li><strong>Memory</strong>: 64GB DDR4-3200</li>
<li><strong>Storage</strong>: Samsung 980 PRO 2TB NVMe SSD</li>
<li><strong>OS</strong>: Ubuntu 22.04 LTS</li>
</ul>
<h3>2. 소프트웨어 요구사항</h3>
<pre class="codehilite"><code class="language-bash"># Python 패키지 설치
pip3 install numpy pandas matplotlib seaborn scipy jinja2

# RocksDB 빌드 (이미 완료되어 있다고 가정)
# db_bench 실행 파일이 현재 디렉토리에 있어야 함

# fio 설치 (이미 설치되어 있다고 가정)
# sudo apt install fio
</code></pre>

<h3>3. 권한 설정</h3>
<pre class="codehilite"><code class="language-bash"># sudo 권한이 필요 (SSD 초기화용)
sudo visudo  # 필요한 경우 사용자 추가

# RocksDB 데이터 디렉토리 권한
sudo chown -R $USER:$USER /rocksdb
</code></pre>

<h3>4. 디스크 공간 확인</h3>
<pre class="codehilite"><code class="language-bash"># 최소 500GB 여유 공간 필요
df -h /rocksdb
</code></pre>

<h2>📊 실험 설정</h2>
<h3><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 설정</h3>
<ul>
<li><strong>fio 벤치마크</strong>: 4K~1M 블록 크기, 1~64 큐 깊이</li>
<li><strong>측정점</strong>: 364개 (9×7×5×5 = 1575개 중 중복 제거)</li>
<li><strong>테스트 시간</strong>: 각 측정점당 5분 + 1분 워밍업</li>
</ul>
<h3><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 설정</h3>
<ul>
<li><strong>데이터 크기</strong>: 10억 키 (약 1TB)</li>
<li><strong>값 크기</strong>: 1024 bytes (1KB)</li>
<li><strong>동시성</strong>: 16 threads</li>
<li><strong>분포</strong>: Uniform Random, Zipfian Random (α=0.99)</li>
<li><strong>로깅</strong>: 1분 간격 성능 통계, 상세한 컴팩션 로그</li>
</ul>
<h2>📁 출력 파일 구조</h2>
<h3><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 출력</h3>
<pre class="codehilite"><code>phase-a/
├── data/
│   ├── fio_grid_initial_results.csv      # 초기 상태 fio 결과
│   └── fio_grid_degraded_results.csv     # 열화 상태 fio 결과
├── results/
│   ├── device_envelope_model.json        # Device Envelope 모델
│   └── phase_a_summary_report.json       # 요약 보고서
└── phase_a_YYYYMMDD_HHMMSS.log          # 실행 로그
</code></pre>

<h3><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 출력</h3>
<pre class="codehilite"><code>phase-b/
├── data/
│   ├── fillrandom_uniform_output.log     # Uniform 분포 실험 출력
│   └── fillrandom_zipfian_output.log     # Zipfian 분포 실험 출력
├── results/
│   ├── phase_b_results.json              # 실험 결과 데이터
│   ├── phase_b_summary_report.json       # 요약 보고서
│   ├── performance_trends.png            # 성능 트렌드 차트
│   ├── compaction_patterns.png           # 컴팩션 패턴 차트
│   └── stabilization_analysis.png        # 안정화 분석 차트
└── phase_b_YYYYMMDD_HHMMSS.log          # 실행 로그
</code></pre>

<h3>공통 출력</h3>
<pre class="codehilite"><code>logs/
├── LOG_YYYYMMDD_HHMMSS                   # RocksDB 메인 로그
├── LOG.old.1_YYYYMMDD_HHMMSS            # 롤링된 로그들
└── ...
</code></pre>

<h2>⚠️ 주의사항</h2>
<h3>1. 실험 순서</h3>
<ul>
<li><strong><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span>를 먼저 실행</strong>하여 초기 상태 측정</li>
<li><strong><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 실험 진행</strong> (FillRandom 실험)</li>
<li><strong><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 재실행</strong>하여 열화 상태 측정</li>
</ul>
<h3>2. 데이터 백업</h3>
<pre class="codehilite"><code class="language-bash"># 중요한 데이터는 백업
cp -r /rocksdb/data /rocksdb/data.backup
</code></pre>

<h3>3. 시스템 모니터링</h3>
<pre class="codehilite"><code class="language-bash"># 실험 중 시스템 상태 모니터링
htop                    # CPU, 메모리 사용률
iotop                   # I/O 사용률
nvidia-smi              # GPU 사용률 (있는 경우)
</code></pre>

<h3>4. 로그 관리</h3>
<pre class="codehilite"><code class="language-bash"># 로그 파일 크기 확인
du -sh logs/
du -sh /rocksdb/data/LOG*
</code></pre>

<h2>🚀 실행 예시</h2>
<h3>전체 실험 실행</h3>
<pre class="codehilite"><code class="language-bash"># 1. <span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 시작 (초기 상태 측정)
python3 scripts/run_phase_a.py

# 2. <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 실행 (FillRandom 실험)
python3 scripts/run_phase_b.py

# 3. <span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 재실행 (열화 상태 측정)
python3 scripts/run_phase_a.py

# 4. 결과 분석
python3 scripts/analyze_logs.py
python3 scripts/generate_report.py
</code></pre>

<h3>개별 실험 실행</h3>
<pre class="codehilite"><code class="language-bash"># <span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span>만 실행
python3 scripts/run_phase_a.py

# <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span>만 실행
python3 scripts/run_phase_b.py

# 로그 분석만 실행
python3 scripts/analyze_logs.py

# 보고서 생성만 실행
python3 scripts/generate_report.py
</code></pre>

<h2>📈 예상 결과</h2>
<h3><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 결과</h3>
<ul>
<li><strong>Device Envelope 모델</strong>: 4D Grid Interpolation + 시간 의존성</li>
<li><strong>성능 열화 분석</strong>: 초기 대비 성능 저하율</li>
<li><strong>예상 열화율</strong>: 쓰기 성능 15-<span class="performance-poor"><span class="performance-poor">20%</span></span> 저하</li>
</ul>
<h3><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 결과</h3>
<ul>
<li><strong>성능 트렌드</strong>: 시간별 처리량, 지연시간 변화</li>
<li><strong>컴팩션 패턴</strong>: 레벨별 컴팩션 빈도, 크기</li>
<li><strong>안정화 분석</strong>: 안정화 가능성, 안정화 시점, 안정적 Put 속도</li>
<li><strong>예상 안정적 Put 속도</strong>: 25,000-35,000 ops/sec</li>
</ul>
<h2>🆘 문제 해결</h2>
<h3>일반적인 문제</h3>
<ol>
<li><strong>권한 오류</strong>: <code>sudo</code> 권한 확인</li>
<li><strong>디스크 공간 부족</strong>: 여유 공간 확인</li>
<li><strong>RocksDB 빌드 오류</strong>: db_bench 실행 파일 확인</li>
<li><strong>fio 설치 오류</strong>: <code>sudo apt install fio</code></li>
</ol>
<h3>로그 확인</h3>
<pre class="codehilite"><code class="language-bash"># 실험 로그 확인
tail -f phase-a/phase_a_*.log
tail -f phase-b/phase_b_*.log

# RocksDB 로그 확인
tail -f /rocksdb/data/LOG
</code></pre>

<h3>실험 중단 및 재시작</h3>
<pre class="codehilite"><code class="language-bash"># 프로세스 확인
ps aux | grep db_bench
ps aux | grep fio

# 프로세스 종료
kill -9 &lt;PID&gt;

# 실험 재시작
python3 scripts/run_phase_a.py  # 또는 run_phase_b.py
</code></pre>

<hr />
<p><strong>실험 시작 전 이 가이드를 숙지하고, 각 단계를 차근차근 진행하세요.</strong></p>
        <div class="footer">
            <p>Report Generated: 2025-09-17 05:26:59</p>
            <p>RocksDB Put-Rate Model Comprehensive Analysis</p>
        </div>
    </div>
</body>
</html>