<!DOCTYPE html>
<html lang="ko">
<head>
    <link rel="stylesheet" href="../styles/project.css">

    <link rel="stylesheet" href="../styles/project.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RocksDB Put-Rate Model Comprehensive Analysis Report</title>
    
</head>
<body>
    <div class="container">
        <h1><span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span>: Device Envelope 모델 구축</h1>
<h2>🎯 목표</h2>
<p>초기상태 장치 성능과 <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 이후 열화된 상태에서의 장치 성능을 측정하여 Device Envelope 모델 구축</p>
<h2>📊 실험 설계</h2>
<h3>1. 초기상태 장치 성능 측정</h3>
<h4>1.1 SSD 완전 초기화</h4>
<p><strong>목적</strong>: 기존 파티션 구조를 완전히 제거하고 전체 장치를 하나의 파티션으로 사용하여 정확한 성능 측정을 수행합니다.</p>
<p><strong>기존 파티션 구조</strong>:
- <code>nvme1n1p1</code>: WAL (Write-Ahead Log) 전용 파티션
- <code>nvme1n1p2</code>: Data 전용 파티션</p>
<p><strong>새로운 구조</strong>: 
- <code>nvme1n1</code>: 전체 장치를 하나의 파티션으로 사용
- <strong>기존 파티션 언마운트</strong>: 
  - <code>sudo umount /dev/nvme1n1p1</code> (WAL 파티션)
  - <code>sudo umount /dev/nvme1n1p2</code> (Data 파티션)
  - <code>sudo umount /dev/nvme1n1</code> (전체 장치)
- <strong>파티션 테이블 삭제</strong>: <code>sudo parted /dev/nvme1n1 mklabel gpt</code>
- <strong>블록 디스카드</strong>: <code>sudo blkdiscard /dev/nvme1n1</code>
- <strong>파일시스템 재생성</strong>: <code>sudo mkfs.f2fs /dev/nvme1n1</code>
- <strong>마운트</strong>: <code>sudo mount /dev/nvme1n1 /rocksdb</code></p>
<h4>1.2 초기 장치 성능 측정</h4>
<ul>
<li><strong>fio 벤치마크</strong>: 4K 블록 크기, 16개 작업</li>
<li><strong>쓰기 성능</strong>: 순차 쓰기, 랜덤 쓰기</li>
<li><strong>읽기 성능</strong>: 순차 읽기, 랜덤 읽기</li>
<li><strong>지연시간</strong>: 평균, <span class="performance-excellent"><span class="performance-excellent">95%</span></span>, <span class="performance-excellent"><span class="performance-excellent">99%</span></span> 지연시간</li>
</ul>
<h4>1.3 Device Envelope 기준선 설정</h4>
<ul>
<li><strong>4D Grid Interpolation</strong>: (ρ_r, qd, numjobs, bs_k)</li>
<li><strong>364개 측정점</strong>: fio 벤치마크 기반</li>
<li><strong>초기 성능 프로파일</strong>: 최적 성능 상태 기록</li>
</ul>
<h3>2. <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 이후 열화상태 장치 성능 측정</h3>
<h4>2.1 <span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 완료 후 측정</h4>
<ul>
<li><strong><span class="phase-indicator phase-b"><span class="phase-indicator phase-b">Phase-B</span></span> 실험 완료 대기</strong>: FillRandom 실험 완료 후</li>
<li><strong>동일한 fio 벤치마크</strong>: 초기 측정과 동일한 조건</li>
<li><strong>열화된 성능 프로파일</strong>: 사용 후 성능 상태 기록</li>
</ul>
<h4>2.2 성능 열화 분석</h4>
<ul>
<li><strong>성능 저하율</strong>: 초기 대비 성능 저하 비율</li>
<li><strong>열화 패턴</strong>: 시간에 따른 성능 변화 패턴</li>
<li><strong>열화 원인</strong>: 쓰기 마모, 컨트롤러 최적화 등</li>
</ul>
<h3>3. Device Envelope 모델 구축</h3>
<h4>3.1 시간 의존적 성능 모델</h4>
<ul>
<li><strong>초기 성능</strong>: 최고 성능 상태 모델</li>
<li><strong>열화 성능</strong>: 사용 후 성능 상태 모델</li>
<li><strong>시간 의존성</strong>: 실험 진행에 따른 성능 변화 모델</li>
</ul>
<h4>3.2 4D Grid Interpolation 확장</h4>
<ul>
<li><strong>시간 차원 추가</strong>: 5D Grid Interpolation (시간 포함)</li>
<li><strong>동적 보간</strong>: 시간에 따른 성능 변화 보간</li>
<li><strong>예측 모델</strong>: 미래 성능 예측 가능</li>
</ul>
<h2>🔧 실험 환경</h2>
<h3>하드웨어</h3>
<ul>
<li><strong>CPU</strong>: Intel i9-12900K (16 cores, 24 threads)</li>
<li><strong>Memory</strong>: 64GB DDR4-3200</li>
<li><strong>Storage</strong>: Samsung 980 PRO 2TB NVMe SSD</li>
<li><strong>OS</strong>: Ubuntu 22.04 LTS</li>
</ul>
<h3>소프트웨어</h3>
<ul>
<li><strong>RocksDB</strong>: Version 8.0.0</li>
<li><strong>Python</strong>: 3.10+</li>
<li><strong>모니터링</strong>: Prometheus + Grafana</li>
</ul>
<h2>📋 실험 절차</h2>
<h3>Day 1: 실험 환경 준비</h3>
<ol>
<li><strong>시스템 설정</strong></li>
<li>RocksDB 컴파일 및 설치</li>
<li>모니터링 도구 설정</li>
<li>
<p>실험 스크립트 준비</p>
</li>
<li>
<p><strong>기본 벤치마크</strong></p>
</li>
<li>기본 성능 측정</li>
<li>시스템 상태 확인</li>
<li>실험 환경 검증</li>
</ol>
<h3>Day 2: FillRandom 특성 분석</h3>
<ol>
<li><strong>키 분포별 실험</strong></li>
<li>균등 분포 실험</li>
<li>지수 분포 실험</li>
<li>
<p>지수분포 실험</p>
</li>
<li>
<p><strong>값 크기별 실험</strong></p>
</li>
<li>1KB 값 실험</li>
<li>10KB 값 실험</li>
<li>
<p>100KB 값 실험</p>
</li>
<li>
<p><strong>동시성별 실험</strong></p>
</li>
<li>1 thread 실험</li>
<li>4 threads 실험</li>
<li>16 threads 실험</li>
<li>64 threads 실험</li>
</ol>
<h3>Day 3: 시간 의존적 성능 측정</h3>
<ol>
<li><strong>24시간 연속 실험</strong></li>
<li>1시간 간격 성능 측정</li>
<li>컴팩션 상태 추적</li>
<li>
<p>리소스 사용량 모니터링</p>
</li>
<li>
<p><strong>데이터 수집</strong></p>
</li>
<li>성능 지표 수집</li>
<li>로그 데이터 수집</li>
<li>메트릭 데이터 수집</li>
</ol>
<h3>Day 4: L2 컴팩션 분석</h3>
<ol>
<li><strong>컴팩션 상태 분석</strong></li>
<li>컴팩션 주기 분석</li>
<li>컴팩션 패턴 분석</li>
<li>
<p>WAF 변화 분석</p>
</li>
<li>
<p><strong>I/O 병목 분석</strong></p>
</li>
<li>I/O 분포 분석</li>
<li>병목 지점 식별</li>
<li>최적화 기회 발굴</li>
</ol>
<h3>Day 5: 결과 분석 및 모델 개발</h3>
<ol>
<li><strong>데이터 분석</strong></li>
<li>수집된 데이터 분석</li>
<li>성능 패턴 분석</li>
<li>
<p>상관관계 분석</p>
</li>
<li>
<p><strong>모델 개발</strong></p>
</li>
<li>FillRandom 특화 모델 개발</li>
<li>시간 의존적 성능 모델 개발</li>
<li>L2 컴팩션 모델 개발</li>
</ol>
<h2>📊 예상 결과</h2>
<h3>1. FillRandom 특화 모델</h3>
<ul>
<li><strong>정확도</strong>: <span class="performance-poor"><span class="performance-poor">5%</span></span> 이하 오차</li>
<li><strong>특성</strong>: 키 분포, 값 크기, 동시성 반영</li>
<li><strong>적용성</strong>: 다양한 FillRandom 시나리오</li>
</ul>
<h3>2. 시간 의존적 성능 모델</h3>
<ul>
<li><strong>정확도</strong>: 시간에 따른 성능 변화 예측</li>
<li><strong>특성</strong>: 컴팩션 상태, 리소스 사용량 반영</li>
<li><strong>적용성</strong>: 장시간 실행 시나리오</li>
</ul>
<h3>3. L2 컴팩션 모델</h3>
<ul>
<li><strong>정확도</strong>: L2 컴팩션 영향 예측</li>
<li><strong>특성</strong>: WAF, I/O 분포, 병목 지점 반영</li>
<li><strong>적용성</strong>: 컴팩션 최적화 시나리오</li>
</ul>
<h2>🎯 성공 지표</h2>
<h3>정량적 지표</h3>
<ul>
<li><strong>FillRandom 모델 정확도</strong>: <span class="performance-poor"><span class="performance-poor">5%</span></span> 이하 오차</li>
<li><strong>시간 의존적 모델 정확도</strong>: <span class="performance-poor"><span class="performance-poor">3%</span></span> 이하 오차</li>
<li><strong>L2 컴팩션 모델 정확도</strong>: <span class="performance-poor"><span class="performance-poor">2%</span></span> 이하 오차</li>
</ul>
<h3>정성적 지표</h3>
<ul>
<li><strong>모델 안정성</strong>: 다양한 조건에서 일관된 성능</li>
<li><strong>모델 해석가능성</strong>: 모델 동작 원리 명확성</li>
<li><strong>모델 확장성</strong>: 다른 워크로드로의 확장 가능성</li>
</ul>
<h2>📁 출력 파일</h2>
<h3>실험 데이터</h3>
<ul>
<li><code>fillrandom_characteristics.json</code>: FillRandom 특성 분석 결과</li>
<li><code>time_dependent_performance.json</code>: 시간 의존적 성능 데이터</li>
<li><code>l2_compaction_analysis.json</code>: L2 컴팩션 분석 결과</li>
</ul>
<h3>모델 파일</h3>
<ul>
<li><code>fillrandom_specialized_model.json</code>: FillRandom 특화 모델</li>
<li><code>time_dependent_model.json</code>: 시간 의존적 성능 모델</li>
<li><code>l2_compaction_model.json</code>: L2 컴팩션 모델</li>
</ul>
<h3>보고서</h3>
<ul>
<li><code>phase_a_report.md</code>: <span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 실험 보고서</li>
<li><code>phase_a_report.html</code>: <span class="phase-indicator phase-a"><span class="phase-indicator phase-a">Phase-A</span></span> 실험 보고서 (HTML)</li>
<li><code>phase_a_visualizations/</code>: 시각화 파일들</li>
</ul>
<hr />
<p><strong>Phase 시작일</strong>: 2025-09-12<br />
<strong>예상 완료일</strong>: 2025-09-16<br />
<strong>총 기간</strong>: 5일<br />
<strong>주요 목표</strong>: FillRandom 특화 모델 개발</p>
        <div class="footer">
            <p>Report Generated: 2025-09-17 05:26:59</p>
            <p>RocksDB Put-Rate Model Comprehensive Analysis</p>
        </div>
    </div>
</body>
</html>