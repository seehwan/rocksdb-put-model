# Phase-A: Device Envelope 모델 구축

## 🎯 목표
초기상태 장치 성능과 Phase-B 이후 열화된 상태에서의 장치 성능을 측정하여 Device Envelope 모델 구축

## 📊 실험 설계

### 1. 초기상태 장치 성능 측정

#### 1.1 SSD 완전 초기화
- **언마운트**: `sudo umount /dev/nvme0n1p1`
- **블록 디스카드**: `sudo blkdiscard /dev/nvme0n1p1`
- **파일시스템 재생성**: `sudo mkfs.f2fs /dev/nvme0n1p1`
- **마운트**: `sudo mount /dev/nvme0n1p1 /rocksdb`

#### 1.2 초기 장치 성능 측정
- **fio 벤치마크**: 4K 블록 크기, 16개 작업
- **쓰기 성능**: 순차 쓰기, 랜덤 쓰기
- **읽기 성능**: 순차 읽기, 랜덤 읽기
- **지연시간**: 평균, 95%, 99% 지연시간

#### 1.3 Device Envelope 기준선 설정
- **4D Grid Interpolation**: (ρ_r, qd, numjobs, bs_k)
- **364개 측정점**: fio 벤치마크 기반
- **초기 성능 프로파일**: 최적 성능 상태 기록

### 2. Phase-B 이후 열화상태 장치 성능 측정

#### 2.1 Phase-B 완료 후 측정
- **Phase-B 실험 완료 대기**: FillRandom 실험 완료 후
- **동일한 fio 벤치마크**: 초기 측정과 동일한 조건
- **열화된 성능 프로파일**: 사용 후 성능 상태 기록

#### 2.2 성능 열화 분석
- **성능 저하율**: 초기 대비 성능 저하 비율
- **열화 패턴**: 시간에 따른 성능 변화 패턴
- **열화 원인**: 쓰기 마모, 컨트롤러 최적화 등

### 3. Device Envelope 모델 구축

#### 3.1 시간 의존적 성능 모델
- **초기 성능**: 최고 성능 상태 모델
- **열화 성능**: 사용 후 성능 상태 모델
- **시간 의존성**: 실험 진행에 따른 성능 변화 모델

#### 3.2 4D Grid Interpolation 확장
- **시간 차원 추가**: 5D Grid Interpolation (시간 포함)
- **동적 보간**: 시간에 따른 성능 변화 보간
- **예측 모델**: 미래 성능 예측 가능

## 🔧 실험 환경

### 하드웨어
- **CPU**: Intel i9-12900K (16 cores, 24 threads)
- **Memory**: 64GB DDR4-3200
- **Storage**: Samsung 980 PRO 2TB NVMe SSD
- **OS**: Ubuntu 22.04 LTS

### 소프트웨어
- **RocksDB**: Version 8.0.0
- **Python**: 3.10+
- **모니터링**: Prometheus + Grafana

## 📋 실험 절차

### Day 1: 실험 환경 준비
1. **시스템 설정**
   - RocksDB 컴파일 및 설치
   - 모니터링 도구 설정
   - 실험 스크립트 준비

2. **기본 벤치마크**
   - 기본 성능 측정
   - 시스템 상태 확인
   - 실험 환경 검증

### Day 2: FillRandom 특성 분석
1. **키 분포별 실험**
   - 균등 분포 실험
   - 지수 분포 실험
   - 지수분포 실험

2. **값 크기별 실험**
   - 1KB 값 실험
   - 10KB 값 실험
   - 100KB 값 실험

3. **동시성별 실험**
   - 1 thread 실험
   - 4 threads 실험
   - 16 threads 실험
   - 64 threads 실험

### Day 3: 시간 의존적 성능 측정
1. **24시간 연속 실험**
   - 1시간 간격 성능 측정
   - 컴팩션 상태 추적
   - 리소스 사용량 모니터링

2. **데이터 수집**
   - 성능 지표 수집
   - 로그 데이터 수집
   - 메트릭 데이터 수집

### Day 4: L2 컴팩션 분석
1. **컴팩션 상태 분석**
   - 컴팩션 주기 분석
   - 컴팩션 패턴 분석
   - WAF 변화 분석

2. **I/O 병목 분석**
   - I/O 분포 분석
   - 병목 지점 식별
   - 최적화 기회 발굴

### Day 5: 결과 분석 및 모델 개발
1. **데이터 분석**
   - 수집된 데이터 분석
   - 성능 패턴 분석
   - 상관관계 분석

2. **모델 개발**
   - FillRandom 특화 모델 개발
   - 시간 의존적 성능 모델 개발
   - L2 컴팩션 모델 개발

## 📊 예상 결과

### 1. FillRandom 특화 모델
- **정확도**: 5% 이하 오차
- **특성**: 키 분포, 값 크기, 동시성 반영
- **적용성**: 다양한 FillRandom 시나리오

### 2. 시간 의존적 성능 모델
- **정확도**: 시간에 따른 성능 변화 예측
- **특성**: 컴팩션 상태, 리소스 사용량 반영
- **적용성**: 장시간 실행 시나리오

### 3. L2 컴팩션 모델
- **정확도**: L2 컴팩션 영향 예측
- **특성**: WAF, I/O 분포, 병목 지점 반영
- **적용성**: 컴팩션 최적화 시나리오

## 🎯 성공 지표

### 정량적 지표
- **FillRandom 모델 정확도**: 5% 이하 오차
- **시간 의존적 모델 정확도**: 3% 이하 오차
- **L2 컴팩션 모델 정확도**: 2% 이하 오차

### 정성적 지표
- **모델 안정성**: 다양한 조건에서 일관된 성능
- **모델 해석가능성**: 모델 동작 원리 명확성
- **모델 확장성**: 다른 워크로드로의 확장 가능성

## 📁 출력 파일

### 실험 데이터
- `fillrandom_characteristics.json`: FillRandom 특성 분석 결과
- `time_dependent_performance.json`: 시간 의존적 성능 데이터
- `l2_compaction_analysis.json`: L2 컴팩션 분석 결과

### 모델 파일
- `fillrandom_specialized_model.json`: FillRandom 특화 모델
- `time_dependent_model.json`: 시간 의존적 성능 모델
- `l2_compaction_model.json`: L2 컴팩션 모델

### 보고서
- `phase_a_report.md`: Phase-A 실험 보고서
- `phase_a_report.html`: Phase-A 실험 보고서 (HTML)
- `phase_a_visualizations/`: 시각화 파일들

---

**Phase 시작일**: 2025-09-12  
**예상 완료일**: 2025-09-16  
**총 기간**: 5일  
**주요 목표**: FillRandom 특화 모델 개발
